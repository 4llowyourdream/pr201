# задаем оценку информационной матрицы руками
hat.I <- matrix(c(16/0.16^2+66/0.66^2,66/0.66^2,
                  66/0.66^2,18/0.18^2+66/0.66^2),nrow=2)
hat.I

# считаем обратную --- это будет оценка ковариационной матрицы ошибок
hat.Var <- solve(hat.I)
hat.Var

# выписываем функцию правдоподобия
lnL <- function(p,X) {
  ans <- X[1]*log(p[1])+X[2]*log(p[2])+
    (100-X[1]-X[2])*log(1-p[1]-p[2])
  return(ans)
}

# считаем её для пробы в нескольких точках
lnL(c(0.2,0.5),c(16,18))
lnL(c(0.2,0.3),c(16,18))

# задаем функцию правдоподобия со знаком минус
minus_lnL <- function(p,X) {
  return(-lnL(p,X))
}

minus_lnL(c(0.2,0.3),c(16,18))

?nlm

# минимизируем минус правдоподобие <=> максимизируем правдоподобие
res <- nlm(minus_lnL,c(1/3,1/3),
           hessian=TRUE,
           X=c(16,18))

res

res$estimate # оценки правдоподобия

solve(res$hessian) # оценка ковариационной матрицы оценок



require(maxLik) # пакет для метода макс. правдоподобия

res2 <- maxLik(lnL,
      start=c(0.1,0.1),X=c(16,18))

summary(res2) # краткий отчет о результатах оценивания
# первый столбик --- сами оценки по методу максимального правдоподобия
# второй столбик --- оценки стандартных ошибок
# т.е. корни из диагональных элементов оценённой ковариационной матрицы

res2$estimate # оценки
res2$hessian # оценка матрицы Гессе

require(quantmod) # пакет для скачивания финансовых данных с google.finance и yahoo.finance

# скачиваем данные о ценах акций гугла
getSymbols(Symbols="GOOG",from="2011-01-01",
           to="2014-01-25")

# вытаскиваем цену закрытия
x <- GOOG$GOOG.Close

x












